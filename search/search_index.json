{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pythomata Python implementation of automata theory. Documentation: https://whitemech.github.io/pythomata. Install from PyPI : pip install pythomata or, from source (e.g. develop branch): pip install git+https://github.com/whitemech/pythomata.git@develop or, clone the repository and install: git clone htts://github.com/whitemech/pythomata.git cd pythomata pip install . How to use Define an automaton: from pythomata import SimpleDFA alphabet = {\"a\", \"b\", \"c\"} states = {\"s1\", \"s2\", \"s3\"} initial_state = \"s1\" accepting_states = {\"s3\"} transition_function = { \"s1\": { \"b\" : \"s1\", \"a\" : \"s2\" }, \"s2\": { \"a\" : \"s3\", \"b\" : \"s1\" }, \"s3\":{ \"c\" : \"s3\" } } dfa = SimpleDFA(states, alphabet, initial_state, accepting_states, transition_function) Test word acceptance: # a word is a list of symbols word = \"bbbac\" dfa.accepts(word) # True # without the last symbol c, the final state is not reached dfa.accepts(word[:-1]) # False Operations such as minimization and trimming: dfa_minimized = dfa.minimize() dfa_trimmed = dfa.trim() Translate into a graphviz.Digraph instance: graph = dfa.minimize().trim().to_graphviz() To print the automaton: graph.render(\"path_to_file\") For that you will need to install Graphviz. Please look at their download page for detailed instructions depending on your system. The output looks like the following: Features Basic DFA and NFA support; Algorithms for DFA minimization and trimming; Algorithm for NFA determinization; Translate automata into Graphviz objects. Support for Symbolic Automata. Tests To run the tests: tox To run only the code style checks: tox -e flake8 -e mypy Docs To build the docs: mkdocs build To view documentation in a browser mkdocs serve and then go to http://localhost:8000 License Pythomata is released under the GNU Lesser General Public License v3.0 or later (LGPLv3+). Copyright 2018-2020 WhiteMech","title":"Home"},{"location":"#pythomata","text":"Python implementation of automata theory. Documentation: https://whitemech.github.io/pythomata.","title":"Pythomata"},{"location":"#install","text":"from PyPI : pip install pythomata or, from source (e.g. develop branch): pip install git+https://github.com/whitemech/pythomata.git@develop or, clone the repository and install: git clone htts://github.com/whitemech/pythomata.git cd pythomata pip install .","title":"Install"},{"location":"#how-to-use","text":"Define an automaton: from pythomata import SimpleDFA alphabet = {\"a\", \"b\", \"c\"} states = {\"s1\", \"s2\", \"s3\"} initial_state = \"s1\" accepting_states = {\"s3\"} transition_function = { \"s1\": { \"b\" : \"s1\", \"a\" : \"s2\" }, \"s2\": { \"a\" : \"s3\", \"b\" : \"s1\" }, \"s3\":{ \"c\" : \"s3\" } } dfa = SimpleDFA(states, alphabet, initial_state, accepting_states, transition_function) Test word acceptance: # a word is a list of symbols word = \"bbbac\" dfa.accepts(word) # True # without the last symbol c, the final state is not reached dfa.accepts(word[:-1]) # False Operations such as minimization and trimming: dfa_minimized = dfa.minimize() dfa_trimmed = dfa.trim() Translate into a graphviz.Digraph instance: graph = dfa.minimize().trim().to_graphviz() To print the automaton: graph.render(\"path_to_file\") For that you will need to install Graphviz. Please look at their download page for detailed instructions depending on your system. The output looks like the following:","title":"How to use"},{"location":"#features","text":"Basic DFA and NFA support; Algorithms for DFA minimization and trimming; Algorithm for NFA determinization; Translate automata into Graphviz objects. Support for Symbolic Automata.","title":"Features"},{"location":"#tests","text":"To run the tests: tox To run only the code style checks: tox -e flake8 -e mypy","title":"Tests"},{"location":"#docs","text":"To build the docs: mkdocs build To view documentation in a browser mkdocs serve and then go to http://localhost:8000","title":"Docs"},{"location":"#license","text":"Pythomata is released under the GNU Lesser General Public License v3.0 or later (LGPLv3+). Copyright 2018-2020 WhiteMech","title":"License"},{"location":"authors/","text":"Credits Maintainers Marco Favorito < marco.favorito@gmail.com > Francesco Fuggitti < francesco.fuggitti@gmail.com > Contributors None yet. Why not be the first ?","title":"Credits"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#maintainers","text":"Marco Favorito < marco.favorito@gmail.com > Francesco Fuggitti < francesco.fuggitti@gmail.com >","title":"Maintainers"},{"location":"authors/#contributors","text":"None yet. Why not be the first ?","title":"Contributors"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. If you need support, want to report/fix a bug, ask for/implement features, you can check the Issues page or submit a Pull request . For other kinds of feedback, you can contact one of the authors by email.","title":"How to contribute"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. If you need support, want to report/fix a bug, ask for/implement features, you can check the Issues page or submit a Pull request . For other kinds of feedback, you can contact one of the authors by email.","title":"Contributing"},{"location":"implement-your-automaton/","text":"Implement your automaton If you are willing to provide your own implementation of an automaton, consider extending the FiniteAutomaton interface defined in pythomata/core.py , or the DFA interface if you are implementing a deterministic automaton.","title":"Implement your automaton"},{"location":"implement-your-automaton/#implement-your-automaton","text":"If you are willing to provide your own implementation of an automaton, consider extending the FiniteAutomaton interface defined in pythomata/core.py , or the DFA interface if you are implementing a deterministic automaton.","title":"Implement your automaton"},{"location":"install/","text":"Install The latest stable version of the package is released on PyPI. So you can install it with pip install pythomata For some advanced features like translation to DOT format, you have to install Graphviz. Please check their Download page to know how to install it on your machine.","title":"Install"},{"location":"install/#install","text":"The latest stable version of the package is released on PyPI. So you can install it with pip install pythomata For some advanced features like translation to DOT format, you have to install Graphviz. Please check their Download page to know how to install it on your machine.","title":"Install"},{"location":"introduction/","text":"Introduction Pythomata provides support for automata theory to the Python programming language. It consists of an implementation-agnostic interface for a generic finite automaton, some implementations of that interface, and other programming utilities for rendering and serialization/deserialization. The installation instruction are here Please have a look to the Quickstart guide to get it started.","title":"Introduction"},{"location":"introduction/#introduction","text":"Pythomata provides support for automata theory to the Python programming language. It consists of an implementation-agnostic interface for a generic finite automaton, some implementations of that interface, and other programming utilities for rendering and serialization/deserialization. The installation instruction are here Please have a look to the Quickstart guide to get it started.","title":"Introduction"},{"location":"quickstart/","text":"Quickstart This guide will show you some examples of use of the package. Formal definition of an automaton Formally, a (deterministic finite) automaton \\mathcal{A} \\mathcal{A} (DFA, see Chapter 2 of [1]) is defined as: \\mathcal{A} = \\langle Q, \\Sigma, q_0, F, \\delta\\rangle \\mathcal{A} = \\langle Q, \\Sigma, q_0, F, \\delta\\rangle Where: Q Q is the (non-empty) finite set of states; \\Sigma \\Sigma is the set of symbols; q_0 \\in Q q_0 \\in Q is the initial state: F \\subseteq Q F \\subseteq Q is the set of accepting states; \\delta: Q \\times \\Sigma \\to Q \\delta: Q \\times \\Sigma \\to Q is the transition function. Example: even number of 0's and 1's Let's design a (deterministic) finite automaton that consider the following language: All the binary strings such that they have an even number of 0's and 1's. An automaton that accepts that language is the following: in particular: the set of states q = \\{q_0, q_1, q_2, q_3\\} q = \\{q_0, q_1, q_2, q_3\\} the alphabet \\sigma = \\{0, 1\\} \\sigma = \\{0, 1\\} the initial state q_0 q_0 the set of accepting states f = \\{q_0\\} f = \\{q_0\\} the transition \\delta \\delta defined as follows: for q_0 q_0 : \\delta(q_0, 0) = q_2 \\delta(q_0, 0) = q_2 and \\delta(q_0, 1) = q_1 \\delta(q_0, 1) = q_1 for q_1 q_1 : \\delta(q_1, 0) = q_3 \\delta(q_1, 0) = q_3 and \\delta(q_1, 1) = q_0 \\delta(q_1, 1) = q_0 for q_2 q_2 : \\delta(q_2, 0) = q_0 \\delta(q_2, 0) = q_0 and \\delta(q_2, 1) = q_3 \\delta(q_2, 1) = q_3 for q_3 q_3 : \\delta(q_3, 0) = q_2 \\delta(q_3, 0) = q_2 and \\delta(q_3, 1) = q_1 \\delta(q_3, 1) = q_1 Using Pythomata The definition in Pythomata is straightforward, since there's a one-to-one mapping to code. the set of states q q : states = {\"q0\", \"q1\", \"q2\", \"q3\"} the alphabet \\sigma \\sigma (i.e. a set of symbols): alphabet = {\"0\", \"1\"} the initial state q_0 q_0 : initial_state = \"q0\" the set of accepting states f f : accepting_states = {\"q0\"} the transition function \\delta \\delta is defined as a nested dictionary: transition_function = { \"q0\": { \"0\": \"q2\", \"1\": \"q1\", }, \"q1\": { \"0\": \"q3\", \"1\": \"q0\", }, \"q2\": { \"0\": \"q0\", \"1\": \"q3\", }, \"q3\": { \"0\": \"q1\", \"1\": \"q2\", } } Now we can instantiate a SimpleDFA object: automaton = SimpleDFA( states=states, alphabet=alphabet, initial_state=initial_state, accepting_states=accepting_states, transition_function=transition_function, ) We can inspect the structure of the automaton: automaton.states # {\"q0\", \"q1\", \"q2\", \"q3\"} automaton.initial_state # \"q0\" automaton.accepting_states # {'q0'} automaton.get_transitions() \"\"\" {('q0', '0', 'q2'), ('q0', '1', 'q1'), ('q1', '0', 'q3'), ('q1', '1', 'q0'), ('q2', '0', 'q0'), ('q2', '1', 'q3'), ('q3', '0', 'q1'), ('q3', '1', 'q2')} \"\"\" The attribute automaton.alphabet is an instance of the Alphabet class. automaton.alphabet.size # 2 list(automaton.alphabet) # ['0', '1'] Now we can check word membership with the accepts method: automaton.accepts(\"\") # True automaton.accepts(\"0\") # False - only one '0' automaton.accepts(\"1\") # False - only one '1' automaton.accepts(\"00\") # True automaton.accepts(\"11\") # True automaton.accepts(\"01\" * 42) # True Rendering Pythomata lets you render the automata by using the graphviz package. Please check the installation section to know what you need to install. Assuming you executed the previous code: digraph = automaton.to_graphviz() # Now `digraph` is a `graphviz.dot.Digraph` object. digraph.render(\"my-even-01-automaton\") Check your current working directory, you should find a file called my-even-01-automaton.svg :","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"This guide will show you some examples of use of the package.","title":"Quickstart"},{"location":"quickstart/#formal-definition-of-an-automaton","text":"Formally, a (deterministic finite) automaton \\mathcal{A} \\mathcal{A} (DFA, see Chapter 2 of [1]) is defined as: \\mathcal{A} = \\langle Q, \\Sigma, q_0, F, \\delta\\rangle \\mathcal{A} = \\langle Q, \\Sigma, q_0, F, \\delta\\rangle Where: Q Q is the (non-empty) finite set of states; \\Sigma \\Sigma is the set of symbols; q_0 \\in Q q_0 \\in Q is the initial state: F \\subseteq Q F \\subseteq Q is the set of accepting states; \\delta: Q \\times \\Sigma \\to Q \\delta: Q \\times \\Sigma \\to Q is the transition function.","title":"Formal definition of an automaton"},{"location":"quickstart/#example-even-number-of-0s-and-1s","text":"Let's design a (deterministic) finite automaton that consider the following language: All the binary strings such that they have an even number of 0's and 1's. An automaton that accepts that language is the following: in particular: the set of states q = \\{q_0, q_1, q_2, q_3\\} q = \\{q_0, q_1, q_2, q_3\\} the alphabet \\sigma = \\{0, 1\\} \\sigma = \\{0, 1\\} the initial state q_0 q_0 the set of accepting states f = \\{q_0\\} f = \\{q_0\\} the transition \\delta \\delta defined as follows: for q_0 q_0 : \\delta(q_0, 0) = q_2 \\delta(q_0, 0) = q_2 and \\delta(q_0, 1) = q_1 \\delta(q_0, 1) = q_1 for q_1 q_1 : \\delta(q_1, 0) = q_3 \\delta(q_1, 0) = q_3 and \\delta(q_1, 1) = q_0 \\delta(q_1, 1) = q_0 for q_2 q_2 : \\delta(q_2, 0) = q_0 \\delta(q_2, 0) = q_0 and \\delta(q_2, 1) = q_3 \\delta(q_2, 1) = q_3 for q_3 q_3 : \\delta(q_3, 0) = q_2 \\delta(q_3, 0) = q_2 and \\delta(q_3, 1) = q_1 \\delta(q_3, 1) = q_1","title":"Example: even number of 0's and 1's"},{"location":"quickstart/#using-pythomata","text":"The definition in Pythomata is straightforward, since there's a one-to-one mapping to code. the set of states q q : states = {\"q0\", \"q1\", \"q2\", \"q3\"} the alphabet \\sigma \\sigma (i.e. a set of symbols): alphabet = {\"0\", \"1\"} the initial state q_0 q_0 : initial_state = \"q0\" the set of accepting states f f : accepting_states = {\"q0\"} the transition function \\delta \\delta is defined as a nested dictionary: transition_function = { \"q0\": { \"0\": \"q2\", \"1\": \"q1\", }, \"q1\": { \"0\": \"q3\", \"1\": \"q0\", }, \"q2\": { \"0\": \"q0\", \"1\": \"q3\", }, \"q3\": { \"0\": \"q1\", \"1\": \"q2\", } } Now we can instantiate a SimpleDFA object: automaton = SimpleDFA( states=states, alphabet=alphabet, initial_state=initial_state, accepting_states=accepting_states, transition_function=transition_function, ) We can inspect the structure of the automaton: automaton.states # {\"q0\", \"q1\", \"q2\", \"q3\"} automaton.initial_state # \"q0\" automaton.accepting_states # {'q0'} automaton.get_transitions() \"\"\" {('q0', '0', 'q2'), ('q0', '1', 'q1'), ('q1', '0', 'q3'), ('q1', '1', 'q0'), ('q2', '0', 'q0'), ('q2', '1', 'q3'), ('q3', '0', 'q1'), ('q3', '1', 'q2')} \"\"\" The attribute automaton.alphabet is an instance of the Alphabet class. automaton.alphabet.size # 2 list(automaton.alphabet) # ['0', '1'] Now we can check word membership with the accepts method: automaton.accepts(\"\") # True automaton.accepts(\"0\") # False - only one '0' automaton.accepts(\"1\") # False - only one '1' automaton.accepts(\"00\") # True automaton.accepts(\"11\") # True automaton.accepts(\"01\" * 42) # True","title":"Using Pythomata"},{"location":"quickstart/#rendering","text":"Pythomata lets you render the automata by using the graphviz package. Please check the installation section to know what you need to install. Assuming you executed the previous code: digraph = automaton.to_graphviz() # Now `digraph` is a `graphviz.dot.Digraph` object. digraph.render(\"my-even-01-automaton\") Check your current working directory, you should find a file called my-even-01-automaton.svg :","title":"Rendering"},{"location":"references/","text":"References John E. Hopcroft, Rajeev Motwani, and Jeffrey D. Ullman. 2006. Introduction to Automata Theory, Languages, and Computation (3rd Edition). Addison-Wesley Longman Publishing Co., Inc., USA.","title":"References"},{"location":"references/#references","text":"John E. Hopcroft, Rajeev Motwani, and Jeffrey D. Ullman. 2006. Introduction to Automata Theory, Languages, and Computation (3rd Edition). Addison-Wesley Longman Publishing Co., Inc., USA.","title":"References"},{"location":"release-history/","text":"Release History 0.1.0 (2019-04-13) Basic support for DFAs and NFAs. Algorithms for DFA minimization and trimming. Algorithm for NFA determinization. 0.2.0 (2019-09-30) Refactoring of the repository 0.3.0 (2020-02-09) Main refactoring of the APIs. Introduce interfaces for better abstractions: Alphabet , FiniteAutomaton etc. DFA and NFA renamed SimpleDFA and SimpleNFA , respectively. Introduced SymbolicAutomaton and SymbolicDFA , where the guards on transitions are propositoinal formulas. 0.3.1 (2020-02-28) Improved CI: using GitHub actions instead of Travis. Included many other checks: safety , black , liccheck . Improved documentation.","title":"Release History"},{"location":"release-history/#release-history","text":"","title":"Release History"},{"location":"release-history/#010-2019-04-13","text":"Basic support for DFAs and NFAs. Algorithms for DFA minimization and trimming. Algorithm for NFA determinization.","title":"0.1.0 (2019-04-13)"},{"location":"release-history/#020-2019-09-30","text":"Refactoring of the repository","title":"0.2.0 (2019-09-30)"},{"location":"release-history/#030-2020-02-09","text":"Main refactoring of the APIs. Introduce interfaces for better abstractions: Alphabet , FiniteAutomaton etc. DFA and NFA renamed SimpleDFA and SimpleNFA , respectively. Introduced SymbolicAutomaton and SymbolicDFA , where the guards on transitions are propositoinal formulas.","title":"0.3.0 (2020-02-09)"},{"location":"release-history/#031-2020-02-28","text":"Improved CI: using GitHub actions instead of Travis. Included many other checks: safety , black , liccheck . Improved documentation.","title":"0.3.1 (2020-02-28)"}]}